\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, amscd, amsthm, amsfonts}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{subfigure}
\usepackage{float}

\oddsidemargin 0pt
\evensidemargin 0pt
\marginparwidth 40pt
\marginparsep 10pt
\topmargin -20pt
\headsep 10pt
\textheight 8.7in
\textwidth 6.65in
\linespread{1.2}

\title{Digital Bubble Level}
\author{Vladislav Pomogaev - 26951160}
\date{September 27, 2021}

\newcommand{\rr}{\mathbb{R}}

\newcommand{\al}{\alpha}
\DeclareMathOperator{\conv}{conv}
\DeclareMathOperator{\aff}{aff}

\begin{document}

\maketitle

\section{Introduction}
This device forms a digital bubble level; also called a spirit level. It can be helpful in levelling things horizontally.
\begin{figure}[H]
    \centering
    \subfigure[]{\includegraphics[width=0.32\textwidth]{tilt_1.png}} 
    \subfigure[]{\includegraphics[width=0.32\textwidth]{tilt_3.png}} 
    \subfigure[]{\includegraphics[width=0.32\textwidth]{tilt_2.png}}
    \caption{Photo stills of the device in action. When you tilt the device to the left as in a), the LEDs to the right light up. As you tilt the device more to the right, the lit LED moves from right to left as in b) and c). When level, the blue center LED lights up.}
    \label{fig:foobar}
\end{figure}

This project consists of a synthesised Verilog design running on an Efinix Xyloni FPGA development board. An accelerometer (MPU-6050) and 9 LEDs are connected to this board.

The Verilog design consists of an FSM (Finite State Machine), and an I\textsuperscript{2}C controller IP block from Efinix. The FSM can send commands to the accelerometer through the I\textsuperscript{2}C controller, which acts as the master. Upon reset, the FSM wakes the accelerometer by writing to a register. Then, in a loop, the FSM requests the acceleration measured in one axis from the accelerometer, and converts the acceleration to a grey-code-like signal which is then output to the LEDs. All of this is done while implementing the communication protocol of the I\textsuperscript{2}C controller. The FSM must request data in the correct format, provide slave address, data, command byte, and number of data bits, wait for response, and check for errors during every read and write command.

\section{Overview}
\begin{figure}[H]
    \centering
\includegraphics[width=0.99\textwidth]{fsm.png}
    \caption{Block diagram of the FSM and how it forms the bubble-level system. The level FSM talks to the I2C core, which communicates to the MPU via a set of buffered GPIO blocks on the FPGA. A reset button resets all FSMs to their initial state. The design runs is compiled for a 50MHz clock constraint.}
    \label{fig:foobar}
\end{figure}

\begin{figure}[H]
    \centering
\includegraphics[width=0.99\textwidth]{tb.png}
    \caption{Block diagram of how the level FSM (not the Efinix i2c core) is connected to the test bench. The test bench is a simple piece of logic that provides timed inputs to the level FSM and asserts that the outputs of the FSM are what are expected.}
    \label{fig:foobar}
\end{figure}

The I2C core provided by Efinix was autogenerated and came with it's own test-bench. Since I did not write this IP or the test bench, I do not include the source code for this report.


\begin{figure}[H]
    \centering
\includegraphics[width=0.99\textwidth]{flow.png}
    \caption{Flow diagram of the internal functioning of the FSM. The assertion of the addresses, data, command byte is done even though it is slightly redundant in this situation to allow for easy expansion of functionality by changing those lines to be tri-state and allowing other modules to write to them.}
    \label{fig:foobar}
\end{figure}

\begin{figure}[H]
    \centering
\includegraphics[width=0.99\textwidth]{data_flow.png}
    \caption{Data flow diagram for the FSM.}
    \label{fig:foobar}
\end{figure}



3. A test bench and at least one module for your FSM. You can have more than two
modules if your FSM requires it. Define the input and output of each module and
a purpose/description of each state for each module. In your test bench, please put
comments on how this will test your FSM. [20]
7. A copy of your code (in Font Size 8) [10] [as a separate file]
8. Simulation waveform results [30].

\end{document}